import * as YAML from 'json-to-pretty-yaml';
import ENV from "../glob/env";
import { Conversation } from "../models";
import { IAIModel, IAIModelPrompt } from "./models/base";
import { GeminiModel } from "./models/gemini";
import { IAITool } from "./tools";
import { GetJiraIssuesTool } from "./tools/get_jira_issues";
import { GetTicketByDescription } from "./tools/get_similar_issues";

class AIAgentService {
    _model: IAIModel

    get model() {
        return this._model ?? (
            this._model = new GeminiModel(ENV.GEMINI_KEY, "gemini-1.5-pro-latest")
        )
    }

    tools: IAITool[] = [
        new GetTicketByDescription(),
        new GetJiraIssuesTool(),
    ]

    async ask(question: string) {
        const history: IAIModelPrompt[] = []
        try {
            const plan = await this.planningAgent(question, history)
            await this.executionAgent(plan, history)
        }
        catch (err) {
            history.push({
                parts: [{
                    text: `Encountered error: ${YAML.stringify(err)}`
                }],
                role: 'model'
            })
        }
        const finalAnswer = await this.finalAnswerAgent(history)
        const res = await Conversation.insertOne({
            question,
            history,
            answer: finalAnswer
        })
        return {
            id: res.insertedId,
            ...finalAnswer
        }
    }

    async planningAgent(query: string, history: IAIModelPrompt[]) {
        const systemPrompt = `You are an AI planning agent work with other agents to provide the best answer to the user query.
            Your job is making an action plan (DO NOT use the functions or execute the plan yourself) by carefully consider:
            - The user query, what information do you need to succesfully fulfill the user question
            - Other agents information / actions / feedbacks about your previous plan. You should do it to optimize your plans
            - You can use the provided functions if needed
            - You can also use your knowledge to construct the plan if it's suitable

            Your plan must meet the following requirements:
            1. It should lead to the final answer / action that accomplish to the user query
            2. It must based on the facts / information provided by the user, and other agents. Don't make facts yourself
            3. It must be a meaningful plan, MUST NOT include code or script`

        return await this.callGeminiAgent(systemPrompt, {
            parts: [
                {
                    text: `This is the user query: ${query}`,
                },
                {
                    text: `This is your functions description: ${this.tools.map(t => YAML.stringify(t.description)).join('\n')}`
                }
            ],
            role: "user"
        }, history, false)
    }

    async executionAgent(plan: IAIModelPrompt, history: IAIModelPrompt[]) {
        const MAX_ITERATION = 20
        const systemPrompt = `You are an AI agent specialized to executing the plan generated by another planning agent.
            Your job is executing the actions by carefully considering the plan and the execution history, which means:
            - You should know which steps are done and what should be doing next
            - If there are something confusing or you cannot do. You can response a feedback to user
            - If the tool return an error or something unexpected. You should analyze it and send a feedback to the planning agent

            Your result must follow these criterias:
            1. When you call a tool function, double check the parameters given in the plan and fix them to ensure the tool run successfully
            2. Your final response to the user must answer the user query with reasoning and citation if possible`

        history.push({
            parts: [
                { text: 'This is the plan from the planning agent. Please execute it!' },
                ...plan.parts
            ],
            role: 'user'
        })
        for (let i = 0; i < MAX_ITERATION; ++i) {
            const content = await this.callGeminiAgent(systemPrompt, undefined, history, true)
            history.push(content)

            let hasFunction = false
            for (const part of content.parts) {
                if (part.functionName) {
                    hasFunction = true
                    console.log(part.functionName)
                    const tool = this.tools.find(t => t.name === part.functionName)
                    const toolContent = await tool.apply(part.functionArgs)
                    history.push(toolContent)
                }
            }

            if (!hasFunction) {
                const answer = content.parts.map(p => p.text).join('\n')
                console.log(`Final answer`, answer.slice(0, 200))
                return content
            }
        }
    }

    async critistAgent(history: IAIModelPrompt[]) {
        const systemPrompt = `You are an AI agent specialized to criticse the work from other agents.
            Your job is checking the output of other agents, criticise them and provide constructive feedback:
            - You main goal is checking if the final answer actually answer the original user query
            - You need to verify if all of the information provided in the final answer should based on ground fact provided during the conversation
            - If you find that the answer is not correct or need to improve, please point out the issues and provide construtive feedback to the planning agent

            Your output MUST:
            1. Only have one number 1 if you think the final answer meets all of the requirement above an can be return to the user
            2. Otherwise, point out the issues and provide your feedback`

        if (history.length <= 0) throw new Error(`[CRICIST AGENT] Cannot answer your query. There's no information to verify`)

        const lastAnswer=  history[history.length - 1]
        history[history.length - 1] = {
            parts: [
                { text: 'This is final answer from the execution agent! Please help me to verify it' },
                ...lastAnswer.parts
            ],
            role: 'user'
        }
        
        const content = await this.callGeminiAgent(systemPrompt, undefined, history, false)
        return content.parts[0].text
    }

    async finalAnswerAgent(history: IAIModelPrompt[]) {
        const systemPrompt = `You are an expert in rewriting content to answer the original query naturally.
            Your job is checking the answer output from another agent for a user query. Try to rewrite it in a conversational context to:
            - Focus on answering the orignal query only
            - Only if needed, enrich it with more information extracted from the conversation history, in order to answer the query in all asked aspects
            - If the final answer is not correct, encoutering error or asking for more information, also try to rewrite in a conversational context`

        const content = await this.callGeminiAgent(systemPrompt, {
            parts: [
                { text: 'The final answer is the last model output. Please proceed it' }
            ],
            role: 'user'
        }, history, false)
        return content
    }

    async callGeminiAgent(systemPrompt: string, newContent: IAIModelPrompt, history: IAIModelPrompt[], useTools: boolean) {
        if (newContent) {
            history.push(newContent)
        }

        console.log(systemPrompt.slice(0, 50), history.map(c => JSON.stringify(c).slice(0, 200)))
        const result = await this.model.generate({
            prompts: history,
            sysInstruction: systemPrompt,
            ...(useTools ? { tools: this.tools } : {})
        })
        console.log(result.usage)
        return result?.prompt
    }
}

export const Agent = new AIAgentService()