import { Content, GenerativeModel, GoogleGenerativeAI } from "@google/generative-ai";
import { ITool } from "./tools";
import { GetJiraIssuesTool } from "./tools/get_jira_issues";
import ENV from "../glob/env";
import { GetTicketByDescription } from "./tools/get_similar_issues";

class AIAgentService {
    _gemini: GenerativeModel

    get gemini() {
        return this._gemini ?? (
            this._gemini = new GoogleGenerativeAI(ENV.GEMINI_KEY).getGenerativeModel({
                model: "gemini-1.5-pro-latest",
                generationConfig: {
                    temperature: 0.3
                }
                // tools: this.GeminiTools
            }, { apiVersion: "v1beta" })
        )
    }

    tools: ITool[] = [
        new GetTicketByDescription(),
        new GetJiraIssuesTool(),
    ]

    get GeminiTools() {
        return [{ functionDeclarations: this.tools.map(t => t.description) }]
    }

    async ask(question: string) {
        const history = []
        const plan = await this.planningAgent(question, history)
        return this.executionAgent(plan, history)
    }

    async planningAgent(query: string, history: Content[]) {
        const systemPrompt = `You are an AI planning agent work with other agents to provide the best answer to the user query.
            Your job is making an action plan (DO NOT use the tools or execute the plan yourself) by carefully consider:
            - The user query, what information do you need to succesfully answer the user question
            - Other agents information / actions / feedbacks about your previous plan. You should you it to optimize your plans
            - The tools you have: The plan should try to make use of the tools to accomplish the user query

            Your plan must meet the following requirements:
            1. It should lead to the final answer / action that accomplish to the user query
            2. It must based on the facts / information provided by the user, tools and other agents. Don't make facts yourself
            3. It should provide details information in each step, so other agents can do their work based on that.`

        return await this.callGeminiAgent(systemPrompt, {
            parts: [
                {
                    text: `This is the user query: ${query}`,
                },
                {
                    text: `This is your tools description: ${this.tools.map(t => JSON.stringify(t.description, null, 2)).join('\n')}`
                }
            ],
            role: "user"
        }, history, false)
    }

    async executionAgent(plan: Content, history: Content[]) {
        const MAX_ITERATION = 20
        const systemPrompt = `You are an AI agent specialized to executing the plan generated by another planning agent.
            Your job is executing the actions by carefully considering the plan and the execution history, which means:
            - You should know which steps are done and what should be doing next
            - If there are something confusing or you cannot do. You can response a feedback to the planning agent
            - If the tool return an error or something unexpected. You should analyze it and send a feedback to the planning agent

            Your result must follow these criterias:
            1. When you call a tool function, double check the parameters given in the plan and fix them to ensure the tool run successfully
            2. Your final response to the user must answer the user query with reasoning and citation if possible
            3. Your final response should also include a summary about your process history. So user can understand your work better.`

        history.push({
            parts: [
                { text: 'This is the plan from the planning agent. Please execute it!' },
                ...plan.parts
            ],
            role: 'user'
        })
        for (let i = 0; i < MAX_ITERATION; ++i) {
            const content = await this.callGeminiAgent(systemPrompt, undefined, history, true)
            history.push(content)

            let hasFunction = false
            for (const part of content.parts) {
                if (part.functionCall?.name) {
                    hasFunction = true
                    console.log(part.functionCall)
                    const tool = this.tools.find(t => t.name === part.functionCall?.name)
                    const toolContent = await tool.apply(part.functionCall.args)
                    history.push(toolContent)
                }
            }

            if (!hasFunction) {
                const answer = content.parts.map(p => p.text).join('\n')
                console.log(`Final answer`, answer.slice(0, 200))
                return content
            }
        }
    }

    async callGeminiAgent(systemPrompt: string, newContent: Content, history: Content[], useTools: boolean) {
        if (newContent) {
            history.push(newContent)
        }

        console.log(systemPrompt.slice(0, 50), history.map(c => JSON.stringify(c).slice(0, 200)))
        const result = await this.gemini.generateContent({
            contents: history,
            systemInstruction: systemPrompt,
            ...(useTools ? { tools: this.GeminiTools } : {})
        })
        console.log(result.response.usageMetadata)
        return result?.response?.candidates[0].content
    }
}

export const Agent = new AIAgentService()